#pragma config(Sensor, port3,  lineDetector,   sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port2,  distanceMM,     sensorVexIQ_Distance)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, openLoop, driveLeft, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, openLoop, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// States for robot behavior
#define WANDERING 0
#define LINE_FOLLOWING 1
#define OBSTACLE_AVOIDANCE 2

// Custom function to stop all motors
void stopAllMotors()
{
    setMotorSpeed(leftMotor, 0);
    setMotorSpeed(rightMotor, 0);
}

task main()
{
    // Constants for distance calculation
    float wheelDiameter = 60.0; // mm, adjust based on actual wheel size
    float distancePerTick = (PI * wheelDiameter) / 360.0; // mm per degree (VEX IQ encoder: 360 degrees per revolution)

    // Logging variables
    long startTime;              // Start time in ms
    float totalDistance = 0;     // Total distance in mm
    float averageSpeed = 0;      // Average speed in mm/s
    float maxAcceleration = 0;   // Max acceleration in mm/s²
    int obstaclesAvoided = 0;    // Number of obstacles avoided
    long timeInWandering = 0;    // Time in wandering state (ms)
    long timeInLineFollowing = 0; // Time in line following state (ms)
    long timeInObstacleAvoidance = 0; // Time in obstacle avoidance state (ms)
    long prevTime;               // Previous timestamp for delta calculations
    float prevLeftEncoder = 0;   // Previous left encoder value
    float prevRightEncoder = 0;  // Previous right encoder value
    float prevSpeed = 0;         // Previous speed for acceleration
    long lastLogTime = 0;        // Last logging timestamp

    // Initialize encoders and timing
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);
    startTime = nSysTime;
    prevTime = startTime;

    // Log CSV header
    writeDebugStreamLine("Time,State,Distance,AvgSpeed,MaxAccel,Obstacles,WanderingTime,LineFollowingTime,ObstacleAvoidanceTime");

    int state = WANDERING;        // Start in wandering mode
    int lineThreshold = 250;      // Line detection threshold
    int distanceThreshold = 210;  // Obstacle distance threshold (mm)
    int currentLineValue;         // Current grayscale value
    int currentDistance;          // Current distance value
    int wanderCounter = 0;        // Counter for random turns
    bool hasStopped = false;      // Flag to track if robot has stopped for avoidance

    setMotorSpeed(leftMotor, 25);
    setMotorSpeed(rightMotor, 25);
    wait1Msec(125);

    while(true)
    {
        // Read sensor values
        currentLineValue = getColorValue(lineDetector);
        currentDistance = getDistanceValue(distanceMM);

        // Calculate timing and performance metrics
        long currentTime = nSysTime;
        long deltaTime = currentTime - prevTime;

        // Distance calculation using encoders
        float leftEncoder = getMotorEncoder(leftMotor);
        float rightEncoder = getMotorEncoder(rightMotor);
        float deltaLeft = leftEncoder - prevLeftEncoder;
        float deltaRight = rightEncoder - prevRightEncoder;
        prevLeftEncoder = leftEncoder;
        prevRightEncoder = rightEncoder;
        float deltaDistance = (deltaLeft + deltaRight) / 2.0 * distancePerTick;
        totalDistance += deltaDistance;

        // Speed and acceleration
        float currentSpeed = (deltaTime > 0) ? (deltaDistance / deltaTime * 1000.0) : 0; // mm/s
        float acceleration = (deltaTime > 0) ? ((currentSpeed - prevSpeed) / deltaTime * 1000.0) : 0; // mm/s²
        if(abs(acceleration) > maxAcceleration) maxAcceleration = abs(acceleration);
        prevSpeed = currentSpeed;

        // Average speed
        averageSpeed = (currentTime > startTime) ? (totalDistance / (currentTime - startTime) * 1000.0) : 0; // mm/s

        // Update time spent in current state
        switch(state)
        {
            case WANDERING: timeInWandering += deltaTime; break;
            case LINE_FOLLOWING: timeInLineFollowing += deltaTime; break;
            case OBSTACLE_AVOIDANCE: timeInObstacleAvoidance += deltaTime; break;
        }

        // State machine
        switch(state)
        {
            case WANDERING:
                wanderCounter++;
                if(wanderCounter >= 5)
                {
                    int turnDirection = random(2);   // 0, 1, or 2
                    if(turnDirection == 0)       // Turn left
                    {
                        setMotorSpeed(leftMotor, 0);
                        setMotorSpeed(rightMotor, 25);
                    }
                    else if(turnDirection == 1)  // Turn right
                    {
                        setMotorSpeed(leftMotor, 25);
                        setMotorSpeed(rightMotor, 0);
                    }
                    else                         // Go forward
                    {
                        setMotorSpeed(leftMotor, 25);
                        setMotorSpeed(rightMotor, 25);
                    }
                    wait1Msec(250);          // Move for 0.5 seconds
                    wanderCounter = 0;       // Reset counter
                }
                if(currentLineValue > 200 & currentLineValue < 310)
                {
                    state = LINE_FOLLOWING;
                }
                else if(currentDistance <= distanceThreshold)
                {
                    state = OBSTACLE_AVOIDANCE;
                    obstaclesAvoided++;  // Increment obstacle count
                    hasStopped = false;  // Reset flag when entering state
                }
                break;

            case LINE_FOLLOWING:
                if(currentLineValue < lineThreshold)   // White surface - turn right
                {
                    setMotorSpeed(leftMotor, 50);
                    setMotorSpeed(rightMotor, 0);
                }
                else if(currentLineValue > lineThreshold & currentLineValue < 330)   // Black line - turn left
                {
                    setMotorSpeed(leftMotor, 0);
                    setMotorSpeed(rightMotor, 50);
                }
                if(currentDistance <= distanceThreshold)
                {
                    state = OBSTACLE_AVOIDANCE;
                    obstaclesAvoided++;  // Increment obstacle count
                    hasStopped = false;  // Reset flag when entering state
                }
                else if(currentLineValue > 310)
                {
                    state = WANDERING;
                }
                break;

            case OBSTACLE_AVOIDANCE:
                if(currentDistance <= distanceThreshold && !hasStopped)
                {
                    int baseSpeed = 50;  // Maximum speed when far
                    int minDistance = 10; // Distance at which speed becomes 0
                    int proportionalSpeed = baseSpeed * (currentDistance - minDistance) / (distanceThreshold - minDistance);
                    if(proportionalSpeed < 0) proportionalSpeed = 0;
                    if(proportionalSpeed > baseSpeed) proportionalSpeed = baseSpeed;
                    setMotorSpeed(leftMotor, proportionalSpeed);
                    setMotorSpeed(rightMotor, proportionalSpeed);
                    if(currentDistance <= 100)
                    {
                        stopAllMotors();    // Stop briefly
                        wait1Msec(500);     // Wait 0.5 second
                        hasStopped = true;  // Mark that we've stopped
                    }
                }
                else if(hasStopped)
                {
                    setMotorSpeed(leftMotor, -50);   // Move backward
                    setMotorSpeed(rightMotor, -50);
                    wait1Msec(500);           // Backward for 0.5 seconds
                    setMotorSpeed(leftMotor, 50);    // Turn right
                    setMotorSpeed(rightMotor, 0);
                    wait1Msec(1000);
                    setMotorSpeed(leftMotor, 50);    // Forward
                    setMotorSpeed(rightMotor, 50);
                    wait1Msec(3000);
                    setMotorSpeed(leftMotor, 0);    // Turn left
                    setMotorSpeed(rightMotor, 50);
                    wait1Msec(2000);
                    setMotorSpeed(leftMotor, 50);    // Forward
                    setMotorSpeed(rightMotor, 50);
                    wait1Msec(2000);
                    currentLineValue = getColorValue(lineDetector);
                    if(currentLineValue <= 310)
                    {
                        state = LINE_FOLLOWING;
                    }
                    else
                    {
                        state = WANDERING;
                    }
                }
                else if(currentDistance > distanceThreshold)
                {
                    state = WANDERING;
                }
                break;
        }

        // Periodic logging every 1000 ms
        if(currentTime - lastLogTime >= 1000)
        {
            writeDebugStreamLine("%d,%d,%.2f,%.2f,%.2f,%d,%d,%d,%d",
                currentTime, state, totalDistance, averageSpeed, maxAcceleration,
                obstaclesAvoided, timeInWandering, timeInLineFollowing, timeInObstacleAvoidance);
            lastLogTime = currentTime;
        }

        // Update previous time for next iteration
        prevTime = currentTime;
    }
}
